<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1085. Sum of Digits in the Minimum Number]]></title>
    <url>%2F2019%2F11%2F11%2F1085-Sum-of-Digits-in-the-Minimum-Number%2F</url>
    <content type="text"><![CDATA[Answer12345678910111213141516class Solution &#123;public: int sumOfDigits(vector&lt;int&gt;&amp; A) &#123; int minNum = INT_MAX; for(auto&amp; num : A) minNum = min(num, minNum); int sum = 0; while(minNum &gt; 0) &#123; sum += minNum%10; minNum = minNum / 10; &#125; return 1- sum%2; &#125;&#125;; ####Think好简单的一道题目，一看竟然是亚麻的，不可思议。这样不可以诶。不过今晚没时间了还是水一道题目去看其他的吧hope everything fine tomorrow.]]></content>
      <categories>
        <category>Leetcode Easy</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1086. High Five]]></title>
    <url>%2F2019%2F11%2F10%2F1086-High-Five%2F</url>
    <content type="text"><![CDATA[ProblemNote: Example Input: Output: Explanation: ExplanationAnswer12345678910111213141516171819202122232425262728293031// 思路：比较简单的一道题目// 创造一个map 来维护学生id和所有成绩// 使用pq来维护前五大成绩// 最后遍历pq来获得总和求得平均数// 复杂度: O(N) // 虽然pq的复杂度应该是O(NlongN)，但是由于我们只维护了5个值，所以heap的深度是一定的class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; highFive(vector&lt;vector&lt;int&gt;&gt;&amp; items) &#123; map&lt;int, priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt;&gt; map; for(auto&amp; item: items) &#123; map[item[0]].push(item[1]); if (map[item[0]].size() &gt; 5) map[item[0]].pop(); &#125; vector&lt;vector&lt;int&gt;&gt; res; for (auto&amp; item: map) &#123; int tmp = 0; while(!map[item.first].empty()) &#123; tmp += map[item.first].top(); map[item.first].pop(); &#125; res.push_back(vector&lt;int&gt;&#123;item.first,tmp/5&#125;); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode Easy</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode - Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1252. Cells with Odd Values in a Matrix]]></title>
    <url>%2F2019%2F11%2F10%2F1252-Cells-with-Odd-Values-in-a-Matrix%2F</url>
    <content type="text"><![CDATA[ProblemNote: Example Input: Output: Explanation: ExplanationAnswer1234567891011121314151617181920212223242526272829// 思路// 1 分别创建行列数组，分别统计行列的相加情况，// *由于我们只需要只要是不是奇数偶数，所以使用^来保留0 或者1// 2 最后遍历二维数组就，判断数值相加是不是偶数 来更新res// 时间复杂度 O(nm) // 空间复杂度 O(n)class Solution &#123;public: int oddCells(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; indices) &#123; vector&lt;int&gt; rows(n, 0); vector&lt;int&gt; cols(m, 0); for(auto&amp; indice: indices) &#123; rows[indice[0]] ^= 1; // 如果是偶数的话就会变成0 cols[indice[1]] ^= 1; &#125; int res = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; res += rows[i] ^ cols[j] == 0 ? 0 : 1; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode Easy</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[643. Maximum Average Subarray I]]></title>
    <url>%2F2019%2F07%2F09%2F643-Maximum-Average-Subarray-I%2F</url>
    <content type="text"><![CDATA[ProblemGiven an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Note: Example Input: [1,12,-5,-6,50,3], k = 4Output: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75Explanation: 12.75 Explanation很简单的一个问题，刚开始没看到开，以为是求子序列的最大平均数。后来发现给定了k，就简单了点就是维持一个长度为k的窗口，从左到右边扫一扫。保存最大的就好很简单 Answer1234567891011121314class Solution &#123;public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123; int res = INT_MIN; int tmp = 0; for (int i = 0; i &lt; k; ++i) tmp += nums[i]; for (int i = k; i &lt; nums.size(); ++i) &#123; res = max(res, tmp); tmp += nums[i] - nums[i-k]; &#125; return (double)max(tmp,res)/k; &#125;&#125;;`]]></content>
      <categories>
        <category>Leetcode Easy</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[838. Push Dominoes]]></title>
    <url>%2F2019%2F07%2F06%2F838-Push-Dominoes%2F</url>
    <content type="text"><![CDATA[Problem There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string “S” representing the initial state. S[i] = &#39;L&#39;, if the i-th domino has been pushed to the left; S[i] = &#39;R&#39;, if the i-th domino has been pushed to the right; S[i] = &#39;.&#39;, if the i-th domino has not been pushed. Return a string representing the final state Example Input: “.L.R…LR..L..”Output: “LL.RR.LLRRLL..” Explanation就只有四种情况 L…L = LLLLLL…R = L…RR…L = RR.LLR…R = R…R 分别对这四种情况进行讨论就行了。找到一个L或R，继续寻找一个L或R，我们只关心他们两个的距离，根据上面四种可能性，分别添加字符具体见代码 Answer1234567891011121314151617181920212223class Solution &#123;public: // L...L = LLLLL // L...R = L...R // R...L = RR.LL // R...R = R...R string pushDominoes(string d) &#123; d = 'L' + d + 'R'; string res = ""; for (int i = 0, j = 1; j &lt; d.length(); ++j)&#123; if (d[j] == '.') continue; int middleNum = j - i - 1; if (i &gt; 0) res += d[i]; if (d[i] == d[j]) res += string(middleNum, d[i]); else if (d[i] == 'L' &amp;&amp; d[j] == 'R') res += string(middleNum, '.'); else res+= string(middleNum/2, 'R') + string( middleNum%2, '.') + string(middleNum/2, 'L'); i = j; &#125; return res; &#125;&#125;;`]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16. 3Sum Closest]]></title>
    <url>%2F2019%2F06%2F28%2F16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[ProblemGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Explanation这道题目意外简单。最先能想到的解法应该是brute-force。但是复杂度O(N^3)明显不会是题目要求的。直接告诉我这类题目应该要先排序一下，复杂度N(LogN)一时间没有什么好想法，于是就想我们可以从第一位到最后一位先扫一遍。确定三个数中的第一个数i: 0 ~ N-1, 在扫的过程中增加两个指针p1和p2。因为我们已经对数组进行排序了，所以可以根据nums[i],nums[p1]和nums[p2]三者的和于target的差值来确定p1,p2指针的移动方向。并且保存与target最相近的那个值。算法复杂度为O(N^2) ps: 为了更快，我们可以在每次计算完三个数的sum时，判断一下是不是等于target的值，如果等于target的值，直接返回就可以了。 Answer12345678910111213141516171819202122class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.size()-2; ++i) &#123; int p1 = i + 1; int p2 = nums.size()-1; while(p1 &lt; p2) &#123; int currSum = nums[i] + nums[p1] + nums[p2]; if (currSum == target) return target; if ( abs(currSum - target) &lt; abs(res - target) ) res = currSum; if (currSum &lt; target) p1++; else p2--; &#125; &#125; return res; &#125;&#125;;`]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>3sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[355. Design Twitter]]></title>
    <url>%2F2019%2F06%2F25%2F355-Design-Twitter%2F</url>
    <content type="text"><![CDATA[ProblemDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee. Example Your Twitter object will be instantiated and called as such: Twitter* obj = new Twitter(); obj-&gt;postTweet(userId,tweetId); vector param_2 = obj-&gt;getNewsFeed(userId); obj-&gt;follow(followerId,followeeId); obj-&gt;unfollow(followerId,followeeId); Twitter twitter = new Twitter(); // User 1 posts a new tweet (id = 5).twitter.postTweet(1, 5); // User 1’s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1); // User 1 follows user 2.twitter.follow(1, 2); // User 2 posts a new tweet (id = 6).twitter.postTweet(2, 6); // User 1’s news feed should return a list with 2 tweet ids -&gt; [6, 5].// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1); // User 1 unfollows user 2.twitter.unfollow(1, 2); // User 1’s news feed should return a list with 1 tweet id -&gt; [5],// since user 1 is no longer following user 2.twitter.getNewsFeed(1); Explanation其实这道题相对简单。四个功能 关注关注的功能比较简单，用unodered_map&lt;userId, unodered_set&lt;followeeId&gt;&gt; 取消关注取消关注的话只需要把对应的unodered_set&lt;followeeId&gt;里面的id删掉就可以了。 发推文（把userId和tweetId绑定）由于最后需要返回最近的推文，和时间有关，因此定义一个pair&lt;tweetId, time&gt;来表示一个推文，time由全局控制。然后同样用unodered_map&lt;userId, unodered_set&lt;tweetId&gt;&gt; 来储存发过的推特。 返回自己和关注的人最近的10条推文vector[tweetId]定义一个priority_queue&lt;pair&lt;tweetId, time&gt;&gt;来根据时间排序。遍历自己发过的推，以及关注的人发过的推。然后储存到pq，当pq大于10个的时候，推出一个。 Answer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768struct CustomCompare&#123; bool operator()(const pair&lt;int,int&gt;&amp; tw1, const pair&lt;int,int&gt;&amp; tw2) &#123; return tw1.second &gt; tw2.second; &#125;&#125;;struct pair_hash &#123; inline std::size_t operator()(const std::pair&lt;int,int&gt; &amp; v) const &#123; return v.first; &#125;&#125;;class Twitter &#123;public: #define TWEET pair&lt;int, int&gt; /** Initialize your data structure here. */ int time = 0; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; followMap; unordered_map&lt;int, unordered_set&lt;TWEET,pair_hash&gt;&gt; postMap; Twitter() &#123; &#125; /** Compose a new tweet. */ void postTweet(int userId, int tweetId) &#123; TWEET tweet = make_pair(tweetId, time++); postMap[userId].insert(tweet); &#125; /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, CustomCompare&gt; pq; unordered_set&lt;TWEET,pair_hash&gt; selfPost = postMap[userId]; for (auto&amp; it : selfPost) &#123; pq.push(it); if (pq.size() &gt; 10) pq.pop(); &#125; for (auto&amp; followeeId: followMap[userId]) &#123; for (auto&amp; it : postMap[followeeId]) &#123; pq.push(it); if (pq.size() &gt; 10) pq.pop(); &#125; &#125; int j = pq.size(); vector&lt;int&gt; res(j); while (!pq.empty()) &#123; res[--j] = pq.top().first; // res.push_front(); pq.pop(); &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) &#123; if (followerId == followeeId) return; followMap[followerId].insert(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) &#123; followMap[followerId].erase(followeeId); &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC创建Spring-boot项目环境]]></title>
    <url>%2F2019%2F06%2F25%2FMAC%E5%88%9B%E5%BB%BASpring-boot%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用brew 更新brewbrew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup 安装Javabrew cask install java 安装完成后，执行java -version. 有输出信息表示安装成功。 设置JAVA环境变量vim ~/.bash_profile 进入环境变量输入export JAVA_HOME=$(/usr/libexec/java_home)保存退出，并执行source ~/.bash_profile执行echo JAVA_HOME，应该可以看得到路径 安装 Mavenbrew install maven 设置环境变量 export M2_HOME=/usr/local/Cellar/maven/{版本号}/export M2=$M2_HOME/binexport PATH=$M2:$JAVA_HOME:$PATH]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[485. Max Consecutive Ones]]></title>
    <url>%2F2019%2F06%2F24%2F485-Max-Consecutive-Ones%2F</url>
    <content type="text"><![CDATA[ProblemGiven a binary array, find the maximum number of consecutive 1s in this array. Example Input: [1,1,0,1,1,1]Output: 3Explanation:The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Explanation好简单而且无聊的一道问题。就贴个答案吧 Answer1234567891011121314class Solution &#123;public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; int res = 0; int tmp = 0; for(int&amp;n : nums)&#123; tmp += n; tmp = tmp*n; res = max(res, tmp); &#125; return res; &#125;&#125;;`]]></content>
      <categories>
        <category>Leetcode Easy</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72. Edit Distance]]></title>
    <url>%2F2019%2F06%2F24%2F72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[ProblemGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a characterDelete a characterReplace a character Example Input: word1 = “horse”, word2 = “ros”Output: 3Explanation: horse -&gt; rorse (replace ‘h’ with ‘r’)rorse -&gt; rose (remove ‘r’)rose -&gt; ros (remove ‘e’) Explanation这是一道DP问题。要求输入从word1变化到word2的最少步骤。题目定义了有三种修改方式分别是插入，替换和删除。我们设定一个DP数组，首先明确DP[i][j] 代表从word1[0…i-1]变化到word2[0…j-1]的最少步骤。 DP初值很明显N长度的字符串变化到空字符串需要N个步骤。所以DP[i][0]=i同理，空字符串转化到N个字符串也需要N个步骤，所以有DP[0][i]=i DP更新假设我们已经知道DP[i-1][j-1]1) 如果word1[i] = words[j]，则DP[i][j]=DP[i-1][j-1]表示无需变化。2) 如果word1[i] != words[j]，分为三种情况a. 替换: word1[i] ==&gt; word2[j]，DP[i][j]=DP[i-1][j-1]+1b. 删除: 删除word1[i-1], 则DP[i][j]=DP[i-1][j]+1c. 增加: 增加word2[j-1], 则DP[i][j]=DP[i][j-1]+1我们只要比较上面三种情况哪种比较小，并更新到DP就可以了。最后返回DP[n][m] Answer123456789101112131415161718192021222324252627class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1,0)); // dp[i][j] indicated the minimum steps // from word1[0...i) to word1[0...j) for (int i = 1; i &lt;= n; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) dp[0][i] = i; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (word1[i-1] == word2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]; &#125;else&#123; int case1 = dp[i-1][j-1]; int case2 = dp[i-1][j]; int case3 = dp[i][j-1]; dp[i][j] = min(case1, min(case2, case3)) + 1; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode Hard</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[376. Wiggle Subsequence]]></title>
    <url>%2F2019%2F06%2F23%2F376-Wiggle-Subsequence%2F</url>
    <content type="text"><![CDATA[ProblemA sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Note: Example Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence. Answer12345678910111213141516171819202122232425262728293031class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n==0) return 0; vector&lt;int&gt; up(n); vector&lt;int&gt; down(n); // set initial values up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i-1]) &#123; up[i] = down[i-1] + 1; down[i] = down[i-1]; &#125;else if (nums[i] &lt; nums[i-1])&#123; down[i] = up[i-1] + 1; up[i] = up[i-1]; &#125;else&#123; down[i] = down[i-1]; up[i] = up[i-1]; &#125; &#125; // return the max result return max(up[n-1], down[n-1]); &#125;&#125;;` Explanation这题采用DP来完成.因为对于某一个数，它可能是下降或者上升，所以定义2个数组，up[]和down[]， up[i]和down[i]表示的是，对于nums[i]，如果它是下降或是上升的话，分别最大长度是多少。判断nums[i]和nums[i-1]的关系，如果nums[i]&gt;nums[i-1]: 那就让up[i]=down[i-1]+1，小于的情况同理。 在返回结果的时候，返回最大长度的那一种可能。]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2F2019%2F06%2F22%2F216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[ProblemFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers.The solution set must not contain duplicate combinations. Example Input: k = 3, n = 7Output: [[1,2,4]]Explanation: Answer123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sol; helper(res, sol, k, n); return res; &#125; void helper(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;sol, int k, int n) &#123; if (sol.size() == k &amp;&amp; n == 0) &#123; res.push_back(sol); return; &#125; for (int i = sol.empty() ? 1 : sol.back() + 1; i &lt;= 9; ++i) &#123; if (n - i &lt; 0) return; sol.push_back(i); helper(res, sol, k, n-i); sol.pop_back(); &#125; &#125;&#125;;` Explanation]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
