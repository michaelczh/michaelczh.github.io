<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[355. Design Twitter]]></title>
    <url>%2F2019%2F06%2F25%2F355-Design-Twitter%2F</url>
    <content type="text"><![CDATA[ProblemDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee. Example Your Twitter object will be instantiated and called as such: Twitter* obj = new Twitter(); obj-&gt;postTweet(userId,tweetId); vector param_2 = obj-&gt;getNewsFeed(userId); obj-&gt;follow(followerId,followeeId); obj-&gt;unfollow(followerId,followeeId); Twitter twitter = new Twitter(); // User 1 posts a new tweet (id = 5).twitter.postTweet(1, 5); // User 1’s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1); // User 1 follows user 2.twitter.follow(1, 2); // User 2 posts a new tweet (id = 6).twitter.postTweet(2, 6); // User 1’s news feed should return a list with 2 tweet ids -&gt; [6, 5].// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1); // User 1 unfollows user 2.twitter.unfollow(1, 2); // User 1’s news feed should return a list with 1 tweet id -&gt; [5],// since user 1 is no longer following user 2.twitter.getNewsFeed(1); Explanation其实这道题相对简单。四个功能 关注关注的功能比较简单，用unodered_map&lt;userId, unodered_set&lt;followeeId&gt;&gt; 取消关注取消关注的话只需要把对应的unodered_set&lt;followeeId&gt;里面的id删掉就可以了。 发推文（把userId和tweetId绑定）由于最后需要返回最近的推文，和时间有关，因此定义一个pair&lt;tweetId, time&gt;来表示一个推文，time由全局控制。然后同样用unodered_map&lt;userId, unodered_set&lt;tweetId&gt;&gt; 来储存发过的推特。 返回自己和关注的人最近的10条推文vector[tweetId]定义一个priority_queue&lt;pair&lt;tweetId, time&gt;&gt;来根据时间排序。遍历自己发过的推，以及关注的人发过的推。然后储存到pq，当pq大于10个的时候，推出一个。 Answerss]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC创建Spring-boot项目环境]]></title>
    <url>%2F2019%2F06%2F25%2FMAC%E5%88%9B%E5%BB%BASpring-boot%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用brew 更新brewbrew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup 安装Javabrew cask install java 安装完成后，执行java -version. 有输出信息表示安装成功。 设置JAVA环境变量vim ~/.bash_profile 进入环境变量输入export JAVA_HOME=$(/usr/libexec/java_home)保存退出，并执行source ~/.bash_profile执行echo JAVA_HOME，应该可以看得到路径 安装Tomcatbrew install tomcat 安装 Mavenbrew install maven 设置环境变量 export M2_HOME=/usr/local/Cellar/maven/{版本号}/export M2=$M2_HOME/binexport PATH=$M2:$JAVA_HOME:$PATH]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[485. Max Consecutive Ones]]></title>
    <url>%2F2019%2F06%2F24%2F485-Max-Consecutive-Ones%2F</url>
    <content type="text"><![CDATA[ProblemGiven a binary array, find the maximum number of consecutive 1s in this array. Example Input: [1,1,0,1,1,1]Output: 3Explanation:The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Explanation好简单而且无聊的一道问题。就贴个答案吧 Answer1234567891011121314class Solution &#123;public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; int res = 0; int tmp = 0; for(int&amp;n : nums)&#123; tmp += n; tmp = tmp*n; res = max(res, tmp); &#125; return res; &#125;&#125;;`]]></content>
      <categories>
        <category>Leetcode Easy</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72. Edit Distance]]></title>
    <url>%2F2019%2F06%2F24%2F72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[ProblemGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a characterDelete a characterReplace a character Example Input: word1 = “horse”, word2 = “ros”Output: 3Explanation: horse -&gt; rorse (replace ‘h’ with ‘r’)rorse -&gt; rose (remove ‘r’)rose -&gt; ros (remove ‘e’) Explanation这是一道DP问题。要求输入从word1变化到word2的最少步骤。题目定义了有三种修改方式分别是插入，替换和删除。我们设定一个DP数组，首先明确DP[i][j] 代表从word1[0…i-1]变化到word2[0…j-1]的最少步骤。 DP初值很明显N长度的字符串变化到空字符串需要N个步骤。所以DP[i][0]=i同理，空字符串转化到N个字符串也需要N个步骤，所以有DP[0][i]=i DP更新假设我们已经知道DP[i-1][j-1]1) 如果word1[i] = words[j]，则DP[i][j]=DP[i-1][j-1]表示无需变化。2) 如果word1[i] != words[j]，分为三种情况a. 替换: word1[i] ==&gt; word2[j]，DP[i][j]=DP[i-1][j-1]+1b. 删除: 删除word1[i-1], 则DP[i][j]=DP[i-1][j]+1c. 增加: 增加word2[j-1], 则DP[i][j]=DP[i][j-1]+1我们只要比较上面三种情况哪种比较小，并更新到DP就可以了。最后返回DP[n][m] Answer123456789101112131415161718192021222324252627class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1,0)); // dp[i][j] indicated the minimum steps // from word1[0...i) to word1[0...j) for (int i = 1; i &lt;= n; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) dp[0][i] = i; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (word1[i-1] == word2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]; &#125;else&#123; int case1 = dp[i-1][j-1]; int case2 = dp[i-1][j]; int case3 = dp[i][j-1]; dp[i][j] = min(case1, min(case2, case3)) + 1; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode Hard</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[376. Wiggle Subsequence]]></title>
    <url>%2F2019%2F06%2F23%2F376-Wiggle-Subsequence%2F</url>
    <content type="text"><![CDATA[ProblemA sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Note: Example Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence. Answer12345678910111213141516171819202122232425262728293031class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n==0) return 0; vector&lt;int&gt; up(n); vector&lt;int&gt; down(n); // set initial values up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i-1]) &#123; up[i] = down[i-1] + 1; down[i] = down[i-1]; &#125;else if (nums[i] &lt; nums[i-1])&#123; down[i] = up[i-1] + 1; up[i] = up[i-1]; &#125;else&#123; down[i] = down[i-1]; up[i] = up[i-1]; &#125; &#125; // return the max result return max(up[n-1], down[n-1]); &#125;&#125;;` Explanation这题采用DP来完成.因为对于某一个数，它可能是下降或者上升，所以定义2个数组，up[]和down[]， up[i]和down[i]表示的是，对于nums[i]，如果它是下降或是上升的话，分别最大长度是多少。判断nums[i]和nums[i-1]的关系，如果nums[i]&gt;nums[i-1]: 那就让up[i]=down[i-1]+1，小于的情况同理。 在返回结果的时候，返回最大长度的那一种可能。]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2F2019%2F06%2F22%2F216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[ProblemFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers.The solution set must not contain duplicate combinations. Example Input: k = 3, n = 7Output: [[1,2,4]]Explanation: Answer123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sol; helper(res, sol, k, n); return res; &#125; void helper(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;sol, int k, int n) &#123; if (sol.size() == k &amp;&amp; n == 0) &#123; res.push_back(sol); return; &#125; for (int i = sol.empty() ? 1 : sol.back() + 1; i &lt;= 9; ++i) &#123; if (n - i &lt; 0) return; sol.push_back(i); helper(res, sol, k, n-i); sol.pop_back(); &#125; &#125;&#125;;` Explanation]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
