<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MAC创建Spring-boot项目环境]]></title>
    <url>%2F2019%2F06%2F25%2FMAC%E5%88%9B%E5%BB%BASpring-boot%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用brew 更新brewbrew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup 安装Javabrew cask install java 安装完成后，执行java -version. 有输出信息表示安装成功。 设置JAVA环境变量vim ~/.bash_profile 进入环境变量输入export JAVA_HOME=$(/usr/libexec/java_home)保存退出，并执行source ~/.bash_profile执行echo JAVA_HOME，应该可以看得到路径 安装Tomcatbrew install tomcat 安装 Mavenbrew install maven 设置环境变量 export M2_HOME=/usr/local/Cellar/maven/{版本号}/export M2=$M2_HOME/binexport PATH=$M2:$JAVA_HOME:$PATH]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[485. Max Consecutive Ones]]></title>
    <url>%2F2019%2F06%2F24%2F485-Max-Consecutive-Ones%2F</url>
    <content type="text"><![CDATA[ProblemGiven a binary array, find the maximum number of consecutive 1s in this array. Example Input: [1,1,0,1,1,1]Output: 3Explanation:The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Explanation好简单而且无聊的一道问题。就贴个答案吧 Answer1234567891011121314class Solution &#123;public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; int res = 0; int tmp = 0; for(int&amp;n : nums)&#123; tmp += n; tmp = tmp*n; res = max(res, tmp); &#125; return res; &#125;&#125;;`]]></content>
      <categories>
        <category>Leetcode Easy</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72. Edit Distance]]></title>
    <url>%2F2019%2F06%2F24%2F72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[ProblemGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a characterDelete a characterReplace a character Example Input: word1 = “horse”, word2 = “ros”Output: 3Explanation: horse -&gt; rorse (replace ‘h’ with ‘r’)rorse -&gt; rose (remove ‘r’)rose -&gt; ros (remove ‘e’) Explanation这是一道DP问题。要求输入从word1变化到word2的最少步骤。题目定义了有三种修改方式分别是插入，替换和删除。我们设定一个DP数组，首先明确DP[i][j] 代表从word1[0…i-1]变化到word2[0…j-1]的最少步骤。 DP初值很明显N长度的字符串变化到空字符串需要N个步骤。所以DP[i][0]=i同理，空字符串转化到N个字符串也需要N个步骤，所以有DP[0][i]=i DP更新假设我们已经知道DP[i-1][j-1]1) 如果word1[i] = words[j]，则DP[i][j]=DP[i-1][j-1]表示无需变化。2) 如果word1[i] != words[j]，分为三种情况a. 替换: word1[i] ==&gt; word2[j]，DP[i][j]=DP[i-1][j-1]+1b. 删除: 删除word1[i-1], 则DP[i][j]=DP[i-1][j]+1c. 增加: 增加word2[j-1], 则DP[i][j]=DP[i][j-1]+1我们只要比较上面三种情况哪种比较小，并更新到DP就可以了。最后返回DP[n][m] Answer123456789101112131415161718192021222324252627class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1,0)); // dp[i][j] indicated the minimum steps // from word1[0...i) to word1[0...j) for (int i = 1; i &lt;= n; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) dp[0][i] = i; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (word1[i-1] == word2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]; &#125;else&#123; int case1 = dp[i-1][j-1]; int case2 = dp[i-1][j]; int case3 = dp[i][j-1]; dp[i][j] = min(case1, min(case2, case3)) + 1; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode Hard</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[376. Wiggle Subsequence]]></title>
    <url>%2F2019%2F06%2F23%2F376-Wiggle-Subsequence%2F</url>
    <content type="text"><![CDATA[ProblemA sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Note: Example Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence. Answer12345678910111213141516171819202122232425262728293031class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n==0) return 0; vector&lt;int&gt; up(n); vector&lt;int&gt; down(n); // set initial values up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i-1]) &#123; up[i] = down[i-1] + 1; down[i] = down[i-1]; &#125;else if (nums[i] &lt; nums[i-1])&#123; down[i] = up[i-1] + 1; up[i] = up[i-1]; &#125;else&#123; down[i] = down[i-1]; up[i] = up[i-1]; &#125; &#125; // return the max result return max(up[n-1], down[n-1]); &#125;&#125;;` Explanation这题采用DP来完成.因为对于某一个数，它可能是下降或者上升，所以定义2个数组，up[]和down[]， up[i]和down[i]表示的是，对于nums[i]，如果它是下降或是上升的话，分别最大长度是多少。判断nums[i]和nums[i-1]的关系，如果nums[i]&gt;nums[i-1]: 那就让up[i]=down[i-1]+1，小于的情况同理。 在返回结果的时候，返回最大长度的那一种可能。]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2F2019%2F06%2F22%2F216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[ProblemFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers.The solution set must not contain duplicate combinations. Example Input: k = 3, n = 7Output: [[1,2,4]]Explanation: Answer123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sol; helper(res, sol, k, n); return res; &#125; void helper(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;sol, int k, int n) &#123; if (sol.size() == k &amp;&amp; n == 0) &#123; res.push_back(sol); return; &#125; for (int i = sol.empty() ? 1 : sol.back() + 1; i &lt;= 9; ++i) &#123; if (n - i &lt; 0) return; sol.push_back(i); helper(res, sol, k, n-i); sol.pop_back(); &#125; &#125;&#125;;` Explanation]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
