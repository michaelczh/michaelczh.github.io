<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[376. Wiggle Subsequence]]></title>
    <url>%2F2019%2F06%2F23%2F376-Wiggle-Subsequence%2F</url>
    <content type="text"><![CDATA[ProblemA sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Note: Example Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence. Answer12345678910111213141516171819202122232425262728293031class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n==0) return 0; vector&lt;int&gt; up(n); vector&lt;int&gt; down(n); // set initial values up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i-1]) &#123; up[i] = down[i-1] + 1; down[i] = down[i-1]; &#125;else if (nums[i] &lt; nums[i-1])&#123; down[i] = up[i-1] + 1; up[i] = up[i-1]; &#125;else&#123; down[i] = down[i-1]; up[i] = up[i-1]; &#125; &#125; // return the max result return max(up[n-1], down[n-1]); &#125;&#125;;` Explanation这题采用DP来完成.因为对于某一个数，它可能是下降或者上升，所以定义2个数组，up[]和down[]， up[i]和down[i]表示的是，对于nums[i]，如果它是下降或是上升的话，分别最大长度是多少。判断nums[i]和nums[i-1]的关系，如果nums[i]&gt;nums[i-1]: 那就让up[i]=down[i-1]+1，小于的情况同理。 在返回结果的时候，返回最大长度的那一种可能。]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2F2019%2F06%2F22%2F216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[ProblemFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers.The solution set must not contain duplicate combinations. Example Input: k = 3, n = 7Output: [[1,2,4]]Explanation: Answer123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sol; helper(res, sol, k, n); return res; &#125; void helper(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;sol, int k, int n) &#123; if (sol.size() == k &amp;&amp; n == 0) &#123; res.push_back(sol); return; &#125; for (int i = sol.empty() ? 1 : sol.back() + 1; i &lt;= 9; ++i) &#123; if (n - i &lt; 0) return; sol.push_back(i); helper(res, sol, k, n-i); sol.pop_back(); &#125; &#125;&#125;;` Explanation]]></content>
      <categories>
        <category>Leetcode Medium</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
